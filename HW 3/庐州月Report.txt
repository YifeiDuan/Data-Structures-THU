A.算法的构思、原理与实现
最开始的想法是外层循环遍历桥，内层循环遍历石材寻找最匹配的，但是这样不仅耗时很长，而且如果不对二者适当排序的话，
得到的答案也是错误的，因为随机顺序之下为一个桥找到价钱最小的石材，很可能会使得总体的花费不能达到最低。
（例如：桥（3，5）（2，9） 石材（3，10）（4，5）（6，9），若按桥的默认顺序如上思路找材料，会花费9，而实际最优为7）
由于桥和石材都有价钱和美化度两个变量，因此无论是二者各自内部排序还是二者之间的比较都涉及到以哪个变量为基准的问题。
如果按照价格排序后再查找匹配，则单次查找无法确定最优方案为何（若是根据美化度尽可能低来选石材，上面例子仍然出错）。
而如果按照美化度排序后再查找匹配，则可以明确以花费尽可能低为匹配原则，而为了避免最开始提到的问题，
应该从美化度需求最高者入手逐一为之匹配石材，这样对一个桥的“最优”可以和整体方案的最优统一起来。
具体思路就是把石材也按美化度高到低排序，每次把美化度高于现在的桥的石材信息加入树中，而树中此前保留下来的石材，
由于美化度高于前面的桥，因而也必然高于现在的桥。因此，插入的时候可以只记录价格信息，也保证了其插入规则的明确性。
每次从树中寻找价格最低者即可，贪心算法可以合理地得到应用。
接下来的问题就全部集中在了树的上面，为了使插入、删除、转动等操作的时间成本降低，使用O(logm)的平衡二叉树，
选择了实现较为简单的splay树。根据关心的问题，设计插入、删除、旋转、splay这几个操作，
再加上一个函数根据桥的价格值寻找树中大于它的最小值；同时，只需用到son[m][2]、father[m]、key[m]这三个数组记录信息，
cnt[m],siz[m]等在庐州月问题里可以不用。实现思路参考了网上的splay树学习笔记cnblogs.com/lazy-people/p/9326556.html

B.问题的认识与解决
1.原本试图归并排序，但是超时，代码复杂难以检查，便改用标准库里的qsort函数，问题可以解决。
2.关于p参数，原本希望用于记录树的规模，因此删除节点时要减小，但是这样导致各数组中元素要整体移动调整，
后来发现p只需要不断增加，表征全过程中插入的节点总量（包括已删除者），保证插入的节点不覆盖此前非空的信息即可，
而树内的节点关联性完全由son、father来确定和访问。
3.insert函数的x原本只传了值，但是在最终插入时无法随即修改其父的son信息，改为传地址即可解决。

C.时间空间复杂度估计
时间复杂度：
qsort的时间复杂度为O(nlogn)（O(mlogm)），splay树各操作的均摊复杂度为O(logm)，对n个桥循环因此是O(nlogm)，
而其他操作如输入、顺次访问等只是O(m)，结合n与m的数量关系，因此最终的总时间复杂度为O(mlogm)。
空间复杂度：
各数组空间复杂度O(m)，insert函数迭代均摊复杂度O(logm)，总空间复杂度为O(m)。