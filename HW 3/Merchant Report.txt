A.算法的构思、原理与实现
在记录各节点的关联边及权重之后，即相当于记录了图的信息，一个比较自然的想法是从零入度点出发不断深入后继，
至找到一个零出度点为一条路径的完成，记录收益信息并不断更新收益最大值及相应的路径。
但是这种算法时间成本太大，每条边的信息会被多次访问，每条从零入度点到零出度点的路径都需要被走完，
为了减少耗时，希望尽可能地在搜索中使每条边只被访问一次（或至少是很有限的几次），进一步地考虑，
就是希望每个节点和一个与之相关的最大收益信息（或者说当前条件下的最大收益）建立起确定的联系，
使得访问到这个节点之后不必再继续访问更多节点即可确定条件最大收益，动态规划的思路可以满足这个需求。
为实现这种思路，需要保证访问一个节点确定其条件最大收益时，其所有前驱或所有后继的条件最大收益已经确定，
将图中节点拓扑排序就可以实现这个目的，而基于这个目的就可以确定每个节点结构体需要记录的信息：
除了邻接点和关联边权重外，为了拓扑排序还需要记录出入度，为了动态规划需要记录条件最大收益及其对应的邻接点。
在实现上，分为录入信息、拓扑排序、动态规划、输出路径四个部分。
录入信息时需记得将起点出度、邻接后继、终点入度、关联边权重这几个信息都加以记录。
拓扑排序时使用零入度算法，用数组实现栈和队列，因此还需随时更新栈顶、队尾作为访问的索引，
由于每个节点的入度是用于入栈，出度是用于出栈时将其后继压入栈，因此为了模仿零入度算法中删除节点及其关联边的操作，
只需每次将搜索到的即将入栈的节点入度减1即可。
由于字典序的规则，条件最大收益要对应于后继而非前驱，才能在路径前端筛选更小序号，
动态规划时从拓扑排序末端开始不断向前记录查找到的条件最大收益及对应的后继节点（相同时取序号更小者）。
完成以上工作后，只需遍历一遍找到最大收益并不断访问其条件最大收益后继即可输出最大收益路径。

B.问题的认识与解决
1.存储空间问题：若使用类似关联矩阵的形式来存储节点信息，则会占用过多空间，因此应该只顺次记录后继和相应关联边权重，
为了尽量避免空间浪费，考虑向量的形式来记录这些信息，设置一个相对合适的初始容量以使均摊的时间复杂度降低。
2.字典序问题：动态规划时记录的信息只能保证从路径第二个节点开始的编号尽量取小，如果两条最大收益路径的起点编号不同，
则只能通过输出前的遍历来确保选择字典序最小者。

C.时间空间复杂度估计
时间复杂度： 
录入的信息，拓扑排序和动态规划都基于逐一考察关联边，因此耗时O(m)；拓扑排序前寻找零入度点为O(n)，
输出前的遍历最坏情况也为O(n)；向量扩容均摊复杂度O(1)。由于n本身也是θ(m)，因此总时间复杂度为O(m)。
空间复杂度：
结构体数组长度为n，因此结构体中的非数组变量占空间O(4n)，而结构体中的数组为关联边，总量为O(m)，栈、队列都为
O(n)的数组。再考虑上n与m的数量关系，所以总的空间复杂度也为O(m)。