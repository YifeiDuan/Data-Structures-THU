A.算法的构思、原理与实现
算法整体框架包括输入序列信息、建立二叉树和按要求遍历这三部分，而每个节点仍然用包含编号和左右子指针的结构体表示。
在输入之后，根据k的不同取值来确定进入不同的模式来建树和遍历输出，因此对每种情况分别设计不同的函数来处理。
建树的关键在于找到一种可以重复的统一模式来把遍历序列信息转化为树的具体结构，由于有父子关系的节点间不能保证相邻，
因而按照从上至下一个一个加入节点的方式难以实现，但是父节点与左右子树之间，无论在哪种输入序列的情形里，
都有位置上的相邻关系，且子树与子树之间互为彼此分隔开的内部完整连续的模块，因此在建树时的基本思路是从根节点开始，
不断通过父节点寻找待建子树在序列中的区间，从上至下使用递归，最终从下至上完成建立。
在每一次递归内部，要记录这个全子树的根节点，然后再找出其左右子树在两个输入序列中的区间，进行下一层递归。
下一个关键问题就是确定左右子树的区间位置，对于输入序列的不同遍历方式，查找位置的方式相应有所不同，但是基本思路类似。
因为子树根一定位于全子树在先序区间中的首位和后序区间中的末位，而输入序列中至少有一个是先/后序，
所以从一次递归传入的区间参数就可以找到此时的根在一个序列中的位置，其左/右子节点的位置有且只有一个与之相邻，
根据另一个序列的遍历方式不同可以找到一个表征左右子树分界位置的节点，先序-右子树根，后序-左子树根，中序-全子树根，
访问该节点位置得到其编号值后再去另一个序列里找相同值，即可将左右子树分开，进一步递归创建。
最后是遍历输出，先、中、后序都可以简单地按照规定顺序递归，层次则需要像2-3Build一样通过一个队首出队尾进的队列实现，
而仅依靠在堆中不连续空间存储的树不能按上述要求建立队列，因此模仿2-3Build使用一个结构体数组，
在case3建树的时候就如同2-3输入那样在数组相应编号位置同步记录信息。

B.问题的认识与解决
1.第一次发现的问题在于对case1、2、3也像0一样默认了是真二叉树，导致一些输入的序列根本无法建树，访问的序列区间会越界，
后来在原来代码的基础上做了调整，在计算左右子树规模后按二者是否为0分类处理，解决了这一问题。
2.第二次大的问题是出现超时，检查代码发现在时间复杂度上的一大优化点在于递归建树时寻找根节点在另一序列位置的方式。
原先是在根据先/后序该节点位置访问得到编号值后，再在另一序列的全子树区间中循环顺次查找值相同的位置，
为了更快地找到这个位置，在输入两个序列的时候就把位置-编号对应关系用两个数组记录，建立起一个类似校验环的关系。
3.最后仍然出现Runtime Error 11，检查没有发现野指针、空指针、越界等问题，猜测可能是递归层数太多导致了栈空间不足，
但是不知道该如何修改，时间有限就暂且搁置了。

C.时间空间复杂度估计
时间复杂度：
输入为O(n)；建树时，对于每个节点都是从上至下递归访问一次，从下至上返回访问一次，其中有有限步的信息记录，故为O(n)；
输出时，先中后序对每个节点都是递归访问-输出-返回，而层次遍历时每个节点是入队-出队，故无论哪种都是O(n)。
所以总的时间复杂度为O(n)。
空间复杂度：
树的存储空间O(n)，而递归建立和遍历输出时最多同时占据O(logn)，所以空间复杂度是O(n+logn)