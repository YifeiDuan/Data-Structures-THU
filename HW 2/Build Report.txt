A.算法的构思、原理与实现
算法主要分成两部分，首先是根据录入的信息创建多叉树，其次是层次遍历输出。
由于多叉树孩子数量不定，难以用统一形式表示节点，因此按照课上介绍的方法用二叉树表达多叉树，
节点信息用结构体表示，左子节点为长子，右子节点为长弟，从而将多叉树节点形式统一化。
在录入信息的时候，需要两层循环，外层控制输入的行数（父节点），内层控制同一行内的输入（子节点依次）。
层次遍历的时候，基本目的是使同辈的节点连续地被访问，如果只通过建立起的数（链表）来访问，
则无法达成这个效果，因为进入子树内部后难以再返回高辈分的层内去找后面的子辈，因而考虑单独建立一个队列来实现。
每次队首后移（相当于原队首出队）的时候其全部子节点就被全部顺次压入队尾，避免了深入子树内部寻找而难以返回高层的问题，
在此基础上，就可以保证同辈的全部子节点无论其根系关系如何都能连续地被弹出，也就实现了层次遍历。

B.问题的认识与解决
数组原本是用一般方法声明，但是会超出栈空间，因此后来改用new的方式从堆中分配空间。
原本在层次遍历队列时是先记录顺序，然后再一起输出，后来发现可以在每次队首后移的时候就把弹出的队首输出，
能减少一轮循环。

C.时间空间复杂度估计
时间复杂度：输入的时候有N行，每行孩子数信息虽不同但是总和必为N，所以输入创建部分复杂度O(2N)，
层次遍历的时候同样是N阶循环，而内部操作次数仍然是正比于每个节点的子节点数量，所以总时间复杂度O(2*2N)=O(N)
空间复杂度：结构体数组（树）和输出数组（队列）规模都是N，因此空间复杂度O(N)