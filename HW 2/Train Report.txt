A.算法的构思、原理与实现
基本思路是要考虑一种可重复的模式（可以通过循环结构实现）来模拟对各车厢进行操作的全过程。
由于a中初始规模和顺序是完全确定的，因此将其作为着眼点，以一节车厢出a作为完成循环中一次可重复逻辑操作的标志。
而在每次对a进行操作之前，需要考虑s中是否有更小的、可以与b接续的车厢出栈。
基于以上两点考虑，主函数循环结构的主体框架和两个辅函数的设计目的就基本认识清楚了。
接下来就是要考虑对于s、a分别进行操作时，如何唯一确定合法的操作对象和类型，以及随时判断输入序列是否不可行。
由于用int数组来模拟栈的功能，所以用一个指示参数num来记录栈顶元素的下标，并在操作中随时更新。
对于s，在每次操作a之前若要操作s，则充要条件是s栈顶的车厢与b顶可接上（即编号恰好大1）。
在主函数对s不断循环判断这个条件直到不满足时跳出，而在operateS函数内只需完成s顶车厢出栈接入b。
对于a，操作使栈顶车厢要么进入b要么进入s，都不可行时可以直接判定整个输入序列不可行。
进入b的充要条件是a顶车厢编号比b顶恰好大1，否则要考虑是否能进入s，首先s已满则不能进入，
而若s顶车厢编号小于a顶车厢编号，则会导致无法出栈，因为出栈入b时编号必然由小到大，因此也可直接判定为不可行。
对于判定不可行的情况，由于输出时顺次遍历ops，因此把ops[1]赋为'N'来指示，同时直接跳出主函数循环。
当以上条件都不满足时，则a顶车厢接入s。对于合法操作，依次记录对象和类型，最终输出。

B.问题的认识与解决
对于主函数内层循环时作为边界条件的numS值，由于循环中numS一直在变小，而j一直++，故会出现问题，
所以将设计的内层循环边界改成不随循环过程而改变的tempS，即这次循环刚开始时s中的车厢数量。

C.时间空间复杂度估计
时间复杂度：主函数关于a的外层循环最多有n次，关于s的内层循环最多有m次，故时间复杂度O(mn)
空间复杂度：五个堆中数组都是n线性的规模，故空间复杂度为O(n)